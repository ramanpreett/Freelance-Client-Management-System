{"ast":null,"code":"import _objectSpread from \"C:/Users/raman/OneDrive/Desktop/project/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"C:/Users/raman/OneDrive/Desktop/project/client/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { IOBuffer } from 'iobuffer';\nimport { deflate } from 'pako';\nimport { writeCrc } from './helpers/crc';\nimport { writeSignature } from './helpers/signature';\nimport { encodetEXt } from './helpers/text';\nimport { InterlaceMethod, ColorType, CompressionMethod, FilterMethod } from './internalTypes';\nconst defaultZlibOptions = {\n  level: 3\n};\nexport default class PngEncoder extends IOBuffer {\n  constructor(data) {\n    var _ref;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    _defineProperty(this, \"_png\", void 0);\n    _defineProperty(this, \"_zlibOptions\", void 0);\n    _defineProperty(this, \"_colorType\", void 0);\n    _defineProperty(this, \"_interlaceMethod\", void 0);\n    this._colorType = ColorType.UNKNOWN;\n    this._zlibOptions = _objectSpread(_objectSpread({}, defaultZlibOptions), options.zlib);\n    this._png = this._checkData(data);\n    this._interlaceMethod = (_ref = options.interlace === 'Adam7' ? InterlaceMethod.ADAM7 : InterlaceMethod.NO_INTERLACE) !== null && _ref !== void 0 ? _ref : InterlaceMethod.NO_INTERLACE;\n    this.setBigEndian();\n  }\n  encode() {\n    writeSignature(this);\n    this.encodeIHDR();\n    if (this._png.palette) {\n      this.encodePLTE();\n      if (this._png.palette[0].length === 4) {\n        this.encodeTRNS();\n      }\n    }\n    this.encodeData();\n    if (this._png.text) {\n      for (const [keyword, text] of Object.entries(this._png.text)) {\n        encodetEXt(this, keyword, text);\n      }\n    }\n    this.encodeIEND();\n    return this.toArray();\n  }\n  // https://www.w3.org/TR/PNG/#11IHDR\n  encodeIHDR() {\n    this.writeUint32(13);\n    this.writeChars('IHDR');\n    this.writeUint32(this._png.width);\n    this.writeUint32(this._png.height);\n    this.writeByte(this._png.depth);\n    this.writeByte(this._colorType);\n    this.writeByte(CompressionMethod.DEFLATE);\n    this.writeByte(FilterMethod.ADAPTIVE);\n    this.writeByte(this._interlaceMethod);\n    writeCrc(this, 17);\n  }\n  // https://www.w3.org/TR/PNG/#11IEND\n  encodeIEND() {\n    this.writeUint32(0);\n    this.writeChars('IEND');\n    writeCrc(this, 4);\n  }\n  encodePLTE() {\n    var _this$_png$palette;\n    const paletteLength = ((_this$_png$palette = this._png.palette) === null || _this$_png$palette === void 0 ? void 0 : _this$_png$palette.length) * 3;\n    this.writeUint32(paletteLength);\n    this.writeChars('PLTE');\n    for (const color of this._png.palette) {\n      this.writeByte(color[0]);\n      this.writeByte(color[1]);\n      this.writeByte(color[2]);\n    }\n    writeCrc(this, 4 + paletteLength);\n  }\n  encodeTRNS() {\n    const alpha = this._png.palette.filter(color => {\n      return color.at(-1) !== 255;\n    });\n    this.writeUint32(alpha.length);\n    this.writeChars('tRNS');\n    for (const el of alpha) {\n      this.writeByte(el.at(-1));\n    }\n    writeCrc(this, 4 + alpha.length);\n  }\n  // https://www.w3.org/TR/PNG/#11IDAT\n  encodeIDAT(data) {\n    this.writeUint32(data.length);\n    this.writeChars('IDAT');\n    this.writeBytes(data);\n    writeCrc(this, data.length + 4);\n  }\n  encodeData() {\n    const {\n      width,\n      height,\n      channels,\n      depth,\n      data\n    } = this._png;\n    const slotsPerLine = depth <= 8 ? Math.ceil(width * depth / 8) * channels : Math.ceil(width * depth / 8 * channels / 2);\n    const newData = new IOBuffer().setBigEndian();\n    let offset = 0;\n    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n      for (let i = 0; i < height; i++) {\n        newData.writeByte(0); // no filter\n        if (depth === 16) {\n          offset = writeDataUint16(data, newData, slotsPerLine, offset);\n        } else {\n          offset = writeDataBytes(data, newData, slotsPerLine, offset);\n        }\n      }\n    } else if (this._interlaceMethod === InterlaceMethod.ADAM7) {\n      // Adam7 interlacing\n      offset = writeDataInterlaced(this._png, data, newData, offset);\n    }\n    const buffer = newData.toArray();\n    const compressed = deflate(buffer, this._zlibOptions);\n    this.encodeIDAT(compressed);\n  }\n  _checkData(data) {\n    const {\n      colorType,\n      channels,\n      depth\n    } = getColorType(data, data.palette);\n    const png = {\n      width: checkInteger(data.width, 'width'),\n      height: checkInteger(data.height, 'height'),\n      channels,\n      data: data.data,\n      depth,\n      text: data.text,\n      palette: data.palette\n    };\n    this._colorType = colorType;\n    const expectedSize = depth < 8 ? Math.ceil(png.width * depth / 8) * png.height * channels : png.width * png.height * channels;\n    if (png.data.length !== expectedSize) {\n      throw new RangeError(\"wrong data size. Found \".concat(png.data.length, \", expected \").concat(expectedSize));\n    }\n    return png;\n  }\n}\nfunction checkInteger(value, name) {\n  if (Number.isInteger(value) && value > 0) {\n    return value;\n  }\n  throw new TypeError(\"\".concat(name, \" must be a positive integer\"));\n}\nfunction getColorType(data, palette) {\n  const {\n    channels = 4,\n    depth = 8\n  } = data;\n  if (channels !== 4 && channels !== 3 && channels !== 2 && channels !== 1) {\n    throw new RangeError(\"unsupported number of channels: \".concat(channels));\n  }\n  const returnValue = {\n    channels,\n    depth,\n    colorType: ColorType.UNKNOWN\n  };\n  switch (channels) {\n    case 4:\n      returnValue.colorType = ColorType.TRUECOLOUR_ALPHA;\n      break;\n    case 3:\n      returnValue.colorType = ColorType.TRUECOLOUR;\n      break;\n    case 1:\n      if (palette) {\n        returnValue.colorType = ColorType.INDEXED_COLOUR;\n      } else {\n        returnValue.colorType = ColorType.GREYSCALE;\n      }\n      break;\n    case 2:\n      returnValue.colorType = ColorType.GREYSCALE_ALPHA;\n      break;\n    default:\n      throw new Error('unsupported number of channels');\n  }\n  return returnValue;\n}\nfunction writeDataBytes(data, newData, slotsPerLine, offset) {\n  for (let j = 0; j < slotsPerLine; j++) {\n    newData.writeByte(data[offset++]);\n  }\n  return offset;\n}\nfunction writeDataInterlaced(imageData, data, newData, offset) {\n  const passes = [{\n    x: 0,\n    y: 0,\n    xStep: 8,\n    yStep: 8\n  }, {\n    x: 4,\n    y: 0,\n    xStep: 8,\n    yStep: 8\n  }, {\n    x: 0,\n    y: 4,\n    xStep: 4,\n    yStep: 8\n  }, {\n    x: 2,\n    y: 0,\n    xStep: 4,\n    yStep: 4\n  }, {\n    x: 0,\n    y: 2,\n    xStep: 2,\n    yStep: 4\n  }, {\n    x: 1,\n    y: 0,\n    xStep: 2,\n    yStep: 2\n  }, {\n    x: 0,\n    y: 1,\n    xStep: 1,\n    yStep: 2\n  }];\n  const {\n    width,\n    height,\n    channels,\n    depth\n  } = imageData;\n  let pixelSize = 0;\n  if (depth === 16) {\n    pixelSize = channels * depth / 8 / 2;\n  } else {\n    pixelSize = channels * depth / 8;\n  }\n  // Process each pass\n  for (let passIndex = 0; passIndex < 7; passIndex++) {\n    const pass = passes[passIndex];\n    const passWidth = Math.floor((width - pass.x + pass.xStep - 1) / pass.xStep);\n    const passHeight = Math.floor((height - pass.y + pass.yStep - 1) / pass.yStep);\n    if (passWidth <= 0 || passHeight <= 0) continue;\n    const passLineBytes = passWidth * pixelSize;\n    // For each scanline in this pass\n    for (let y = 0; y < passHeight; y++) {\n      const imageY = pass.y + y * pass.yStep;\n      // Extract raw scanline data\n      const rawScanline = depth <= 8 ? new Uint8Array(passLineBytes) : new Uint16Array(passLineBytes);\n      let rawOffset = 0;\n      for (let x = 0; x < passWidth; x++) {\n        const imageX = pass.x + x * pass.xStep;\n        if (imageX < width && imageY < height) {\n          const srcPos = (imageY * width + imageX) * pixelSize;\n          for (let i = 0; i < pixelSize; i++) {\n            rawScanline[rawOffset++] = data[srcPos + i];\n          }\n        }\n      }\n      newData.writeByte(0); // no filter\n      if (depth === 8) {\n        newData.writeBytes(rawScanline);\n      } else if (depth === 16) {\n        for (const value of rawScanline) {\n          newData.writeByte(value >> 8 & 0xff); // High byte\n          newData.writeByte(value & 0xff);\n        }\n      }\n    }\n  }\n  return offset;\n}\nfunction writeDataUint16(data, newData, slotsPerLine, offset) {\n  for (let j = 0; j < slotsPerLine; j++) {\n    newData.writeUint16(data[offset++]);\n  }\n  return offset;\n}","map":{"version":3,"names":["IOBuffer","deflate","writeCrc","writeSignature","encodetEXt","InterlaceMethod","ColorType","CompressionMethod","FilterMethod","defaultZlibOptions","level","PngEncoder","constructor","data","_ref","options","arguments","length","undefined","_defineProperty","_colorType","UNKNOWN","_zlibOptions","_objectSpread","zlib","_png","_checkData","_interlaceMethod","interlace","ADAM7","NO_INTERLACE","setBigEndian","encode","encodeIHDR","palette","encodePLTE","encodeTRNS","encodeData","text","keyword","Object","entries","encodeIEND","toArray","writeUint32","writeChars","width","height","writeByte","depth","DEFLATE","ADAPTIVE","_this$_png$palette","paletteLength","color","alpha","filter","at","el","encodeIDAT","writeBytes","channels","slotsPerLine","Math","ceil","newData","offset","i","writeDataUint16","writeDataBytes","writeDataInterlaced","buffer","compressed","colorType","getColorType","png","checkInteger","expectedSize","RangeError","concat","value","name","Number","isInteger","TypeError","returnValue","TRUECOLOUR_ALPHA","TRUECOLOUR","INDEXED_COLOUR","GREYSCALE","GREYSCALE_ALPHA","Error","j","imageData","passes","x","y","xStep","yStep","pixelSize","passIndex","pass","passWidth","floor","passHeight","passLineBytes","imageY","rawScanline","Uint8Array","Uint16Array","rawOffset","imageX","srcPos","writeUint16"],"sources":["C:\\Users\\raman\\OneDrive\\Desktop\\project\\client\\node_modules\\fast-png\\src\\PngEncoder.ts"],"sourcesContent":["import { IOBuffer } from 'iobuffer';\nimport { deflate } from 'pako';\n\nimport { writeCrc } from './helpers/crc';\nimport { writeSignature } from './helpers/signature';\nimport { encodetEXt } from './helpers/text';\nimport {\n  InterlaceMethod,\n  ColorType,\n  CompressionMethod,\n  FilterMethod,\n} from './internalTypes';\nimport type {\n  DeflateFunctionOptions,\n  PngEncoderOptions,\n  ImageData,\n  PngDataArray,\n  BitDepth,\n  IndexedColors,\n} from './types';\n\nconst defaultZlibOptions: DeflateFunctionOptions = {\n  level: 3,\n};\n\ninterface PngToEncode {\n  width: number;\n  height: number;\n  data: PngDataArray;\n  depth: BitDepth;\n  channels: number;\n  text?: ImageData['text'];\n  palette?: IndexedColors;\n}\n\nexport default class PngEncoder extends IOBuffer {\n  private readonly _png: PngToEncode;\n  private readonly _zlibOptions: DeflateFunctionOptions;\n  private _colorType: ColorType;\n  private readonly _interlaceMethod: InterlaceMethod;\n  public constructor(data: ImageData, options: PngEncoderOptions = {}) {\n    super();\n    this._colorType = ColorType.UNKNOWN;\n    this._zlibOptions = { ...defaultZlibOptions, ...options.zlib };\n    this._png = this._checkData(data);\n\n    this._interlaceMethod =\n      (options.interlace === 'Adam7'\n        ? InterlaceMethod.ADAM7\n        : InterlaceMethod.NO_INTERLACE) ?? InterlaceMethod.NO_INTERLACE;\n    this.setBigEndian();\n  }\n\n  public encode(): Uint8Array {\n    writeSignature(this);\n    this.encodeIHDR();\n    if (this._png.palette) {\n      this.encodePLTE();\n      if (this._png.palette[0].length === 4) {\n        this.encodeTRNS();\n      }\n    }\n\n    this.encodeData();\n    if (this._png.text) {\n      for (const [keyword, text] of Object.entries(this._png.text)) {\n        encodetEXt(this, keyword, text);\n      }\n    }\n    this.encodeIEND();\n    return this.toArray();\n  }\n\n  // https://www.w3.org/TR/PNG/#11IHDR\n  private encodeIHDR(): void {\n    this.writeUint32(13);\n\n    this.writeChars('IHDR');\n\n    this.writeUint32(this._png.width);\n    this.writeUint32(this._png.height);\n    this.writeByte(this._png.depth);\n    this.writeByte(this._colorType);\n    this.writeByte(CompressionMethod.DEFLATE);\n    this.writeByte(FilterMethod.ADAPTIVE);\n    this.writeByte(this._interlaceMethod);\n\n    writeCrc(this, 17);\n  }\n\n  // https://www.w3.org/TR/PNG/#11IEND\n  private encodeIEND(): void {\n    this.writeUint32(0);\n\n    this.writeChars('IEND');\n\n    writeCrc(this, 4);\n  }\n\n  private encodePLTE() {\n    const paletteLength = (this._png.palette?.length as number) * 3;\n    this.writeUint32(paletteLength);\n    this.writeChars('PLTE');\n    for (const color of this._png.palette as IndexedColors) {\n      this.writeByte(color[0]);\n      this.writeByte(color[1]);\n      this.writeByte(color[2]);\n    }\n    writeCrc(this, 4 + paletteLength);\n  }\n\n  private encodeTRNS() {\n    const alpha = (this._png.palette as IndexedColors).filter((color) => {\n      return color.at(-1) !== 255;\n    });\n    this.writeUint32(alpha.length);\n    this.writeChars('tRNS');\n    for (const el of alpha) {\n      this.writeByte(el.at(-1) as number);\n    }\n    writeCrc(this, 4 + alpha.length);\n  }\n\n  // https://www.w3.org/TR/PNG/#11IDAT\n  private encodeIDAT(data: PngDataArray): void {\n    this.writeUint32(data.length);\n    this.writeChars('IDAT');\n\n    this.writeBytes(data);\n\n    writeCrc(this, data.length + 4);\n  }\n\n  private encodeData(): void {\n    const { width, height, channels, depth, data } = this._png;\n    const slotsPerLine =\n      depth <= 8\n        ? Math.ceil((width * depth) / 8) * channels\n        : Math.ceil((((width * depth) / 8) * channels) / 2);\n\n    const newData = new IOBuffer().setBigEndian();\n    let offset = 0;\n    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n      for (let i = 0; i < height; i++) {\n        newData.writeByte(0); // no filter\n        if (depth === 16) {\n          offset = writeDataUint16(data, newData, slotsPerLine, offset);\n        } else {\n          offset = writeDataBytes(data, newData, slotsPerLine, offset);\n        }\n      }\n    } else if (this._interlaceMethod === InterlaceMethod.ADAM7) {\n      // Adam7 interlacing\n      offset = writeDataInterlaced(this._png, data, newData, offset);\n    }\n    const buffer = newData.toArray();\n    const compressed = deflate(buffer, this._zlibOptions);\n    this.encodeIDAT(compressed);\n  }\n\n  private _checkData(data: ImageData): PngToEncode {\n    const { colorType, channels, depth } = getColorType(data, data.palette);\n\n    const png: PngToEncode = {\n      width: checkInteger(data.width, 'width'),\n      height: checkInteger(data.height, 'height'),\n      channels,\n      data: data.data,\n      depth,\n      text: data.text,\n      palette: data.palette,\n    };\n    this._colorType = colorType;\n    const expectedSize =\n      depth < 8\n        ? Math.ceil((png.width * depth) / 8) * png.height * channels\n        : png.width * png.height * channels;\n\n    if (png.data.length !== expectedSize) {\n      throw new RangeError(\n        `wrong data size. Found ${png.data.length}, expected ${expectedSize}`,\n      );\n    }\n    return png;\n  }\n}\n\nfunction checkInteger(value: number, name: string): number {\n  if (Number.isInteger(value) && value > 0) {\n    return value;\n  }\n  throw new TypeError(`${name} must be a positive integer`);\n}\n\ninterface GetColorTypeReturn {\n  channels: number;\n  depth: BitDepth;\n  colorType: ColorType;\n}\n\nfunction getColorType(\n  data: ImageData,\n  palette?: IndexedColors,\n): GetColorTypeReturn {\n  const { channels = 4, depth = 8 } = data;\n  if (channels !== 4 && channels !== 3 && channels !== 2 && channels !== 1) {\n    throw new RangeError(`unsupported number of channels: ${channels}`);\n  }\n\n  const returnValue: GetColorTypeReturn = {\n    channels,\n    depth,\n    colorType: ColorType.UNKNOWN,\n  };\n  switch (channels) {\n    case 4:\n      returnValue.colorType = ColorType.TRUECOLOUR_ALPHA;\n      break;\n    case 3:\n      returnValue.colorType = ColorType.TRUECOLOUR;\n      break;\n    case 1:\n      if (palette) {\n        returnValue.colorType = ColorType.INDEXED_COLOUR;\n      } else {\n        returnValue.colorType = ColorType.GREYSCALE;\n      }\n      break;\n    case 2:\n      returnValue.colorType = ColorType.GREYSCALE_ALPHA;\n      break;\n    default:\n      throw new Error('unsupported number of channels');\n  }\n  return returnValue;\n}\n\nfunction writeDataBytes(\n  data: PngDataArray,\n  newData: IOBuffer,\n  slotsPerLine: number,\n  offset: number,\n): number {\n  for (let j = 0; j < slotsPerLine; j++) {\n    newData.writeByte(data[offset++]);\n  }\n  return offset;\n}\n\nfunction writeDataInterlaced(\n  imageData: PngToEncode,\n  data: PngDataArray,\n  newData: IOBuffer,\n  offset: number,\n) {\n  const passes = [\n    { x: 0, y: 0, xStep: 8, yStep: 8 },\n    { x: 4, y: 0, xStep: 8, yStep: 8 },\n    { x: 0, y: 4, xStep: 4, yStep: 8 },\n    { x: 2, y: 0, xStep: 4, yStep: 4 },\n    { x: 0, y: 2, xStep: 2, yStep: 4 },\n    { x: 1, y: 0, xStep: 2, yStep: 2 },\n    { x: 0, y: 1, xStep: 1, yStep: 2 },\n  ];\n  const { width, height, channels, depth } = imageData;\n  let pixelSize = 0;\n  if (depth === 16) {\n    pixelSize = (channels * depth) / 8 / 2;\n  } else {\n    pixelSize = (channels * depth) / 8;\n  }\n  // Process each pass\n  for (let passIndex = 0; passIndex < 7; passIndex++) {\n    const pass = passes[passIndex];\n    const passWidth = Math.floor(\n      (width - pass.x + pass.xStep - 1) / pass.xStep,\n    );\n    const passHeight = Math.floor(\n      (height - pass.y + pass.yStep - 1) / pass.yStep,\n    );\n\n    if (passWidth <= 0 || passHeight <= 0) continue;\n    const passLineBytes = passWidth * pixelSize;\n    // For each scanline in this pass\n    for (let y = 0; y < passHeight; y++) {\n      const imageY = pass.y + y * pass.yStep;\n      // Extract raw scanline data\n      const rawScanline =\n        depth <= 8\n          ? new Uint8Array(passLineBytes)\n          : new Uint16Array(passLineBytes);\n\n      let rawOffset = 0;\n      for (let x = 0; x < passWidth; x++) {\n        const imageX = pass.x + x * pass.xStep;\n        if (imageX < width && imageY < height) {\n          const srcPos = (imageY * width + imageX) * pixelSize;\n          for (let i = 0; i < pixelSize; i++) {\n            rawScanline[rawOffset++] = data[srcPos + i];\n          }\n        }\n      }\n      newData.writeByte(0); // no filter\n      if (depth === 8) {\n        newData.writeBytes(rawScanline);\n      } else if (depth === 16) {\n        for (const value of rawScanline) {\n          newData.writeByte((value >> 8) & 0xff); // High byte\n          newData.writeByte(value & 0xff);\n        }\n      }\n    }\n  }\n  return offset;\n}\n\nfunction writeDataUint16(\n  data: PngDataArray,\n  newData: IOBuffer,\n  slotsPerLine: number,\n  offset: number,\n): number {\n  for (let j = 0; j < slotsPerLine; j++) {\n    newData.writeUint16(data[offset++]);\n  }\n  return offset;\n}\n"],"mappings":";;AAAA,SAASA,QAAQ,QAAQ,UAAU;AACnC,SAASC,OAAO,QAAQ,MAAM;AAE9B,SAASC,QAAQ,QAAQ,eAAe;AACxC,SAASC,cAAc,QAAQ,qBAAqB;AACpD,SAASC,UAAU,QAAQ,gBAAgB;AAC3C,SACEC,eAAe,EACfC,SAAS,EACTC,iBAAiB,EACjBC,YAAY,QACP,iBAAiB;AAUxB,MAAMC,kBAAkB,GAA2B;EACjDC,KAAK,EAAE;CACR;AAYD,eAAc,MAAOC,UAAW,SAAQX,QAAQ;EAK9CY,YAAmBC,IAAe,EAAiC;IAAA,IAAAC,IAAA;IAAA,IAA/BC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA6B,EAAE;IACjE,KAAK,EAAE;IAACG,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IACR,IAAI,CAACC,UAAU,GAAGd,SAAS,CAACe,OAAO;IACnC,IAAI,CAACC,YAAY,GAAAC,aAAA,CAAAA,aAAA,KAAQd,kBAAkB,GAAKM,OAAO,CAACS,IAAI,CAAE;IAC9D,IAAI,CAACC,IAAI,GAAG,IAAI,CAACC,UAAU,CAACb,IAAI,CAAC;IAEjC,IAAI,CAACc,gBAAgB,IAAAb,IAAA,GAClBC,OAAO,CAACa,SAAS,KAAK,OAAO,GAC1BvB,eAAe,CAACwB,KAAK,GACrBxB,eAAe,CAACyB,YAAY,cAAAhB,IAAA,cAAAA,IAAA,GAAKT,eAAe,CAACyB,YAAY;IACnE,IAAI,CAACC,YAAY,EAAE;EACrB;EAEOC,MAAMA,CAAA;IACX7B,cAAc,CAAC,IAAI,CAAC;IACpB,IAAI,CAAC8B,UAAU,EAAE;IACjB,IAAI,IAAI,CAACR,IAAI,CAACS,OAAO,EAAE;MACrB,IAAI,CAACC,UAAU,EAAE;MACjB,IAAI,IAAI,CAACV,IAAI,CAACS,OAAO,CAAC,CAAC,CAAC,CAACjB,MAAM,KAAK,CAAC,EAAE;QACrC,IAAI,CAACmB,UAAU,EAAE;MACnB;IACF;IAEA,IAAI,CAACC,UAAU,EAAE;IACjB,IAAI,IAAI,CAACZ,IAAI,CAACa,IAAI,EAAE;MAClB,KAAK,MAAM,CAACC,OAAO,EAAED,IAAI,CAAC,IAAIE,MAAM,CAACC,OAAO,CAAC,IAAI,CAAChB,IAAI,CAACa,IAAI,CAAC,EAAE;QAC5DlC,UAAU,CAAC,IAAI,EAAEmC,OAAO,EAAED,IAAI,CAAC;MACjC;IACF;IACA,IAAI,CAACI,UAAU,EAAE;IACjB,OAAO,IAAI,CAACC,OAAO,EAAE;EACvB;EAEA;EACQV,UAAUA,CAAA;IAChB,IAAI,CAACW,WAAW,CAAC,EAAE,CAAC;IAEpB,IAAI,CAACC,UAAU,CAAC,MAAM,CAAC;IAEvB,IAAI,CAACD,WAAW,CAAC,IAAI,CAACnB,IAAI,CAACqB,KAAK,CAAC;IACjC,IAAI,CAACF,WAAW,CAAC,IAAI,CAACnB,IAAI,CAACsB,MAAM,CAAC;IAClC,IAAI,CAACC,SAAS,CAAC,IAAI,CAACvB,IAAI,CAACwB,KAAK,CAAC;IAC/B,IAAI,CAACD,SAAS,CAAC,IAAI,CAAC5B,UAAU,CAAC;IAC/B,IAAI,CAAC4B,SAAS,CAACzC,iBAAiB,CAAC2C,OAAO,CAAC;IACzC,IAAI,CAACF,SAAS,CAACxC,YAAY,CAAC2C,QAAQ,CAAC;IACrC,IAAI,CAACH,SAAS,CAAC,IAAI,CAACrB,gBAAgB,CAAC;IAErCzB,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC;EACpB;EAEA;EACQwC,UAAUA,CAAA;IAChB,IAAI,CAACE,WAAW,CAAC,CAAC,CAAC;IAEnB,IAAI,CAACC,UAAU,CAAC,MAAM,CAAC;IAEvB3C,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC;EACnB;EAEQiC,UAAUA,CAAA;IAAA,IAAAiB,kBAAA;IAChB,MAAMC,aAAa,GAAI,EAAAD,kBAAA,OAAI,CAAC3B,IAAI,CAACS,OAAO,cAAAkB,kBAAA,uBAAjBA,kBAAA,CAAmBnC,MAAiB,IAAG,CAAC;IAC/D,IAAI,CAAC2B,WAAW,CAACS,aAAa,CAAC;IAC/B,IAAI,CAACR,UAAU,CAAC,MAAM,CAAC;IACvB,KAAK,MAAMS,KAAK,IAAI,IAAI,CAAC7B,IAAI,CAACS,OAAwB,EAAE;MACtD,IAAI,CAACc,SAAS,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC;MACxB,IAAI,CAACN,SAAS,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC;MACxB,IAAI,CAACN,SAAS,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC;IAC1B;IACApD,QAAQ,CAAC,IAAI,EAAE,CAAC,GAAGmD,aAAa,CAAC;EACnC;EAEQjB,UAAUA,CAAA;IAChB,MAAMmB,KAAK,GAAI,IAAI,CAAC9B,IAAI,CAACS,OAAyB,CAACsB,MAAM,CAAEF,KAAK,IAAI;MAClE,OAAOA,KAAK,CAACG,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG;IAC7B,CAAC,CAAC;IACF,IAAI,CAACb,WAAW,CAACW,KAAK,CAACtC,MAAM,CAAC;IAC9B,IAAI,CAAC4B,UAAU,CAAC,MAAM,CAAC;IACvB,KAAK,MAAMa,EAAE,IAAIH,KAAK,EAAE;MACtB,IAAI,CAACP,SAAS,CAACU,EAAE,CAACD,EAAE,CAAC,CAAC,CAAC,CAAW,CAAC;IACrC;IACAvD,QAAQ,CAAC,IAAI,EAAE,CAAC,GAAGqD,KAAK,CAACtC,MAAM,CAAC;EAClC;EAEA;EACQ0C,UAAUA,CAAC9C,IAAkB;IACnC,IAAI,CAAC+B,WAAW,CAAC/B,IAAI,CAACI,MAAM,CAAC;IAC7B,IAAI,CAAC4B,UAAU,CAAC,MAAM,CAAC;IAEvB,IAAI,CAACe,UAAU,CAAC/C,IAAI,CAAC;IAErBX,QAAQ,CAAC,IAAI,EAAEW,IAAI,CAACI,MAAM,GAAG,CAAC,CAAC;EACjC;EAEQoB,UAAUA,CAAA;IAChB,MAAM;MAAES,KAAK;MAAEC,MAAM;MAAEc,QAAQ;MAAEZ,KAAK;MAAEpC;IAAI,CAAE,GAAG,IAAI,CAACY,IAAI;IAC1D,MAAMqC,YAAY,GAChBb,KAAK,IAAI,CAAC,GACNc,IAAI,CAACC,IAAI,CAAElB,KAAK,GAAGG,KAAK,GAAI,CAAC,CAAC,GAAGY,QAAQ,GACzCE,IAAI,CAACC,IAAI,CAAIlB,KAAK,GAAGG,KAAK,GAAI,CAAC,GAAIY,QAAQ,GAAI,CAAC,CAAC;IAEvD,MAAMI,OAAO,GAAG,IAAIjE,QAAQ,EAAE,CAAC+B,YAAY,EAAE;IAC7C,IAAImC,MAAM,GAAG,CAAC;IACd,IAAI,IAAI,CAACvC,gBAAgB,KAAKtB,eAAe,CAACyB,YAAY,EAAE;MAC1D,KAAK,IAAIqC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpB,MAAM,EAAEoB,CAAC,EAAE,EAAE;QAC/BF,OAAO,CAACjB,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;QACtB,IAAIC,KAAK,KAAK,EAAE,EAAE;UAChBiB,MAAM,GAAGE,eAAe,CAACvD,IAAI,EAAEoD,OAAO,EAAEH,YAAY,EAAEI,MAAM,CAAC;QAC/D,CAAC,MAAM;UACLA,MAAM,GAAGG,cAAc,CAACxD,IAAI,EAAEoD,OAAO,EAAEH,YAAY,EAAEI,MAAM,CAAC;QAC9D;MACF;IACF,CAAC,MAAM,IAAI,IAAI,CAACvC,gBAAgB,KAAKtB,eAAe,CAACwB,KAAK,EAAE;MAC1D;MACAqC,MAAM,GAAGI,mBAAmB,CAAC,IAAI,CAAC7C,IAAI,EAAEZ,IAAI,EAAEoD,OAAO,EAAEC,MAAM,CAAC;IAChE;IACA,MAAMK,MAAM,GAAGN,OAAO,CAACtB,OAAO,EAAE;IAChC,MAAM6B,UAAU,GAAGvE,OAAO,CAACsE,MAAM,EAAE,IAAI,CAACjD,YAAY,CAAC;IACrD,IAAI,CAACqC,UAAU,CAACa,UAAU,CAAC;EAC7B;EAEQ9C,UAAUA,CAACb,IAAe;IAChC,MAAM;MAAE4D,SAAS;MAAEZ,QAAQ;MAAEZ;IAAK,CAAE,GAAGyB,YAAY,CAAC7D,IAAI,EAAEA,IAAI,CAACqB,OAAO,CAAC;IAEvE,MAAMyC,GAAG,GAAgB;MACvB7B,KAAK,EAAE8B,YAAY,CAAC/D,IAAI,CAACiC,KAAK,EAAE,OAAO,CAAC;MACxCC,MAAM,EAAE6B,YAAY,CAAC/D,IAAI,CAACkC,MAAM,EAAE,QAAQ,CAAC;MAC3Cc,QAAQ;MACRhD,IAAI,EAAEA,IAAI,CAACA,IAAI;MACfoC,KAAK;MACLX,IAAI,EAAEzB,IAAI,CAACyB,IAAI;MACfJ,OAAO,EAAErB,IAAI,CAACqB;KACf;IACD,IAAI,CAACd,UAAU,GAAGqD,SAAS;IAC3B,MAAMI,YAAY,GAChB5B,KAAK,GAAG,CAAC,GACLc,IAAI,CAACC,IAAI,CAAEW,GAAG,CAAC7B,KAAK,GAAGG,KAAK,GAAI,CAAC,CAAC,GAAG0B,GAAG,CAAC5B,MAAM,GAAGc,QAAQ,GAC1Dc,GAAG,CAAC7B,KAAK,GAAG6B,GAAG,CAAC5B,MAAM,GAAGc,QAAQ;IAEvC,IAAIc,GAAG,CAAC9D,IAAI,CAACI,MAAM,KAAK4D,YAAY,EAAE;MACpC,MAAM,IAAIC,UAAU,2BAAAC,MAAA,CACQJ,GAAG,CAAC9D,IAAI,CAACI,MAAM,iBAAA8D,MAAA,CAAcF,YAAY,CAAE,CACtE;IACH;IACA,OAAOF,GAAG;EACZ;;AAGF,SAASC,YAAYA,CAACI,KAAa,EAAEC,IAAY;EAC/C,IAAIC,MAAM,CAACC,SAAS,CAACH,KAAK,CAAC,IAAIA,KAAK,GAAG,CAAC,EAAE;IACxC,OAAOA,KAAK;EACd;EACA,MAAM,IAAII,SAAS,IAAAL,MAAA,CAAIE,IAAI,gCAA6B,CAAC;AAC3D;AAQA,SAASP,YAAYA,CACnB7D,IAAe,EACfqB,OAAuB;EAEvB,MAAM;IAAE2B,QAAQ,GAAG,CAAC;IAAEZ,KAAK,GAAG;EAAC,CAAE,GAAGpC,IAAI;EACxC,IAAIgD,QAAQ,KAAK,CAAC,IAAIA,QAAQ,KAAK,CAAC,IAAIA,QAAQ,KAAK,CAAC,IAAIA,QAAQ,KAAK,CAAC,EAAE;IACxE,MAAM,IAAIiB,UAAU,oCAAAC,MAAA,CAAoClB,QAAQ,CAAE,CAAC;EACrE;EAEA,MAAMwB,WAAW,GAAuB;IACtCxB,QAAQ;IACRZ,KAAK;IACLwB,SAAS,EAAEnE,SAAS,CAACe;GACtB;EACD,QAAQwC,QAAQ;IACd,KAAK,CAAC;MACJwB,WAAW,CAACZ,SAAS,GAAGnE,SAAS,CAACgF,gBAAgB;MAClD;IACF,KAAK,CAAC;MACJD,WAAW,CAACZ,SAAS,GAAGnE,SAAS,CAACiF,UAAU;MAC5C;IACF,KAAK,CAAC;MACJ,IAAIrD,OAAO,EAAE;QACXmD,WAAW,CAACZ,SAAS,GAAGnE,SAAS,CAACkF,cAAc;MAClD,CAAC,MAAM;QACLH,WAAW,CAACZ,SAAS,GAAGnE,SAAS,CAACmF,SAAS;MAC7C;MACA;IACF,KAAK,CAAC;MACJJ,WAAW,CAACZ,SAAS,GAAGnE,SAAS,CAACoF,eAAe;MACjD;IACF;MACE,MAAM,IAAIC,KAAK,CAAC,gCAAgC,CAAC;EACrD;EACA,OAAON,WAAW;AACpB;AAEA,SAAShB,cAAcA,CACrBxD,IAAkB,EAClBoD,OAAiB,EACjBH,YAAoB,EACpBI,MAAc;EAEd,KAAK,IAAI0B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9B,YAAY,EAAE8B,CAAC,EAAE,EAAE;IACrC3B,OAAO,CAACjB,SAAS,CAACnC,IAAI,CAACqD,MAAM,EAAE,CAAC,CAAC;EACnC;EACA,OAAOA,MAAM;AACf;AAEA,SAASI,mBAAmBA,CAC1BuB,SAAsB,EACtBhF,IAAkB,EAClBoD,OAAiB,EACjBC,MAAc;EAEd,MAAM4B,MAAM,GAAG,CACb;IAAEC,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;IAAEC,KAAK,EAAE,CAAC;IAAEC,KAAK,EAAE;EAAC,CAAE,EAClC;IAAEH,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;IAAEC,KAAK,EAAE,CAAC;IAAEC,KAAK,EAAE;EAAC,CAAE,EAClC;IAAEH,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;IAAEC,KAAK,EAAE,CAAC;IAAEC,KAAK,EAAE;EAAC,CAAE,EAClC;IAAEH,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;IAAEC,KAAK,EAAE,CAAC;IAAEC,KAAK,EAAE;EAAC,CAAE,EAClC;IAAEH,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;IAAEC,KAAK,EAAE,CAAC;IAAEC,KAAK,EAAE;EAAC,CAAE,EAClC;IAAEH,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;IAAEC,KAAK,EAAE,CAAC;IAAEC,KAAK,EAAE;EAAC,CAAE,EAClC;IAAEH,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;IAAEC,KAAK,EAAE,CAAC;IAAEC,KAAK,EAAE;EAAC,CAAE,CACnC;EACD,MAAM;IAAEpD,KAAK;IAAEC,MAAM;IAAEc,QAAQ;IAAEZ;EAAK,CAAE,GAAG4C,SAAS;EACpD,IAAIM,SAAS,GAAG,CAAC;EACjB,IAAIlD,KAAK,KAAK,EAAE,EAAE;IAChBkD,SAAS,GAAItC,QAAQ,GAAGZ,KAAK,GAAI,CAAC,GAAG,CAAC;EACxC,CAAC,MAAM;IACLkD,SAAS,GAAItC,QAAQ,GAAGZ,KAAK,GAAI,CAAC;EACpC;EACA;EACA,KAAK,IAAImD,SAAS,GAAG,CAAC,EAAEA,SAAS,GAAG,CAAC,EAAEA,SAAS,EAAE,EAAE;IAClD,MAAMC,IAAI,GAAGP,MAAM,CAACM,SAAS,CAAC;IAC9B,MAAME,SAAS,GAAGvC,IAAI,CAACwC,KAAK,CAC1B,CAACzD,KAAK,GAAGuD,IAAI,CAACN,CAAC,GAAGM,IAAI,CAACJ,KAAK,GAAG,CAAC,IAAII,IAAI,CAACJ,KAAK,CAC/C;IACD,MAAMO,UAAU,GAAGzC,IAAI,CAACwC,KAAK,CAC3B,CAACxD,MAAM,GAAGsD,IAAI,CAACL,CAAC,GAAGK,IAAI,CAACH,KAAK,GAAG,CAAC,IAAIG,IAAI,CAACH,KAAK,CAChD;IAED,IAAII,SAAS,IAAI,CAAC,IAAIE,UAAU,IAAI,CAAC,EAAE;IACvC,MAAMC,aAAa,GAAGH,SAAS,GAAGH,SAAS;IAC3C;IACA,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,UAAU,EAAER,CAAC,EAAE,EAAE;MACnC,MAAMU,MAAM,GAAGL,IAAI,CAACL,CAAC,GAAGA,CAAC,GAAGK,IAAI,CAACH,KAAK;MACtC;MACA,MAAMS,WAAW,GACf1D,KAAK,IAAI,CAAC,GACN,IAAI2D,UAAU,CAACH,aAAa,CAAC,GAC7B,IAAII,WAAW,CAACJ,aAAa,CAAC;MAEpC,IAAIK,SAAS,GAAG,CAAC;MACjB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGO,SAAS,EAAEP,CAAC,EAAE,EAAE;QAClC,MAAMgB,MAAM,GAAGV,IAAI,CAACN,CAAC,GAAGA,CAAC,GAAGM,IAAI,CAACJ,KAAK;QACtC,IAAIc,MAAM,GAAGjE,KAAK,IAAI4D,MAAM,GAAG3D,MAAM,EAAE;UACrC,MAAMiE,MAAM,GAAG,CAACN,MAAM,GAAG5D,KAAK,GAAGiE,MAAM,IAAIZ,SAAS;UACpD,KAAK,IAAIhC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgC,SAAS,EAAEhC,CAAC,EAAE,EAAE;YAClCwC,WAAW,CAACG,SAAS,EAAE,CAAC,GAAGjG,IAAI,CAACmG,MAAM,GAAG7C,CAAC,CAAC;UAC7C;QACF;MACF;MACAF,OAAO,CAACjB,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;MACtB,IAAIC,KAAK,KAAK,CAAC,EAAE;QACfgB,OAAO,CAACL,UAAU,CAAC+C,WAAW,CAAC;MACjC,CAAC,MAAM,IAAI1D,KAAK,KAAK,EAAE,EAAE;QACvB,KAAK,MAAM+B,KAAK,IAAI2B,WAAW,EAAE;UAC/B1C,OAAO,CAACjB,SAAS,CAAEgC,KAAK,IAAI,CAAC,GAAI,IAAI,CAAC,CAAC,CAAC;UACxCf,OAAO,CAACjB,SAAS,CAACgC,KAAK,GAAG,IAAI,CAAC;QACjC;MACF;IACF;EACF;EACA,OAAOd,MAAM;AACf;AAEA,SAASE,eAAeA,CACtBvD,IAAkB,EAClBoD,OAAiB,EACjBH,YAAoB,EACpBI,MAAc;EAEd,KAAK,IAAI0B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9B,YAAY,EAAE8B,CAAC,EAAE,EAAE;IACrC3B,OAAO,CAACgD,WAAW,CAACpG,IAAI,CAACqD,MAAM,EAAE,CAAC,CAAC;EACrC;EACA,OAAOA,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}