{"ast":null,"code":"import _defineProperty from \"C:/Users/raman/OneDrive/Desktop/project/client/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { IOBuffer } from 'iobuffer';\nimport { inflate, Inflate as Inflator } from 'pako';\nimport { checkCrc } from './helpers/crc';\nimport { decodeInterlaceAdam7 } from './helpers/decodeInterlaceAdam7';\nimport { decodeInterlaceNull } from './helpers/decodeInterlaceNull';\nimport { checkSignature } from './helpers/signature';\nimport { decodetEXt, readKeyword, textChunkName } from './helpers/text';\nimport { ColorType, CompressionMethod, DisposeOpType, FilterMethod, InterlaceMethod, BlendOpType } from './internalTypes';\nexport default class PngDecoder extends IOBuffer {\n  constructor(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(data);\n    _defineProperty(this, \"_checkCrc\", void 0);\n    _defineProperty(this, \"_inflator\", void 0);\n    _defineProperty(this, \"_png\", void 0);\n    _defineProperty(this, \"_apng\", void 0);\n    _defineProperty(this, \"_end\", void 0);\n    _defineProperty(this, \"_hasPalette\", void 0);\n    _defineProperty(this, \"_palette\", void 0);\n    _defineProperty(this, \"_hasTransparency\", void 0);\n    _defineProperty(this, \"_transparency\", void 0);\n    _defineProperty(this, \"_compressionMethod\", void 0);\n    _defineProperty(this, \"_filterMethod\", void 0);\n    _defineProperty(this, \"_interlaceMethod\", void 0);\n    _defineProperty(this, \"_colorType\", void 0);\n    _defineProperty(this, \"_isAnimated\", void 0);\n    _defineProperty(this, \"_numberOfFrames\", void 0);\n    _defineProperty(this, \"_numberOfPlays\", void 0);\n    _defineProperty(this, \"_frames\", void 0);\n    _defineProperty(this, \"_writingDataChunks\", void 0);\n    const {\n      checkCrc = false\n    } = options;\n    this._checkCrc = checkCrc;\n    this._inflator = new Inflator();\n    this._png = {\n      width: -1,\n      height: -1,\n      channels: -1,\n      data: new Uint8Array(0),\n      depth: 1,\n      text: {}\n    };\n    this._apng = {\n      width: -1,\n      height: -1,\n      channels: -1,\n      depth: 1,\n      numberOfFrames: 1,\n      numberOfPlays: 0,\n      text: {},\n      frames: []\n    };\n    this._end = false;\n    this._hasPalette = false;\n    this._palette = [];\n    this._hasTransparency = false;\n    this._transparency = new Uint16Array(0);\n    this._compressionMethod = CompressionMethod.UNKNOWN;\n    this._filterMethod = FilterMethod.UNKNOWN;\n    this._interlaceMethod = InterlaceMethod.UNKNOWN;\n    this._colorType = ColorType.UNKNOWN;\n    this._isAnimated = false;\n    this._numberOfFrames = 1;\n    this._numberOfPlays = 0;\n    this._frames = [];\n    this._writingDataChunks = false;\n    // PNG is always big endian\n    // https://www.w3.org/TR/PNG/#7Integers-and-byte-order\n    this.setBigEndian();\n  }\n  decode() {\n    checkSignature(this);\n    while (!this._end) {\n      const length = this.readUint32();\n      const type = this.readChars(4);\n      this.decodeChunk(length, type);\n    }\n    this.decodeImage();\n    return this._png;\n  }\n  decodeApng() {\n    checkSignature(this);\n    while (!this._end) {\n      const length = this.readUint32();\n      const type = this.readChars(4);\n      this.decodeApngChunk(length, type);\n    }\n    this.decodeApngImage();\n    return this._apng;\n  }\n  // https://www.w3.org/TR/PNG/#5Chunk-layout\n  decodeChunk(length, type) {\n    const offset = this.offset;\n    switch (type) {\n      // 11.2 Critical chunks\n      case 'IHDR':\n        // 11.2.2 IHDR Image header\n        this.decodeIHDR();\n        break;\n      case 'PLTE':\n        // 11.2.3 PLTE Palette\n        this.decodePLTE(length);\n        break;\n      case 'IDAT':\n        // 11.2.4 IDAT Image data\n        this.decodeIDAT(length);\n        break;\n      case 'IEND':\n        // 11.2.5 IEND Image trailer\n        this._end = true;\n        break;\n      // 11.3 Ancillary chunks\n      case 'tRNS':\n        // 11.3.2.1 tRNS Transparency\n        this.decodetRNS(length);\n        break;\n      case 'iCCP':\n        // 11.3.3.3 iCCP Embedded ICC profile\n        this.decodeiCCP(length);\n        break;\n      case textChunkName:\n        // 11.3.4.3 tEXt Textual data\n        decodetEXt(this._png.text, this, length);\n        break;\n      case 'pHYs':\n        // 11.3.5.3 pHYs Physical pixel dimensions\n        this.decodepHYs();\n        break;\n      default:\n        this.skip(length);\n        break;\n    }\n    if (this.offset - offset !== length) {\n      throw new Error(\"Length mismatch while decoding chunk \".concat(type));\n    }\n    if (this._checkCrc) {\n      checkCrc(this, length + 4, type);\n    } else {\n      this.skip(4);\n    }\n  }\n  decodeApngChunk(length, type) {\n    const offset = this.offset;\n    if (type !== 'fdAT' && type !== 'IDAT' && this._writingDataChunks) {\n      this.pushDataToFrame();\n    }\n    switch (type) {\n      case 'acTL':\n        this.decodeACTL();\n        break;\n      case 'fcTL':\n        this.decodeFCTL();\n        break;\n      case 'fdAT':\n        this.decodeFDAT(length);\n        break;\n      default:\n        this.decodeChunk(length, type);\n        this.offset = offset + length;\n        break;\n    }\n    if (this.offset - offset !== length) {\n      throw new Error(\"Length mismatch while decoding chunk \".concat(type));\n    }\n    if (this._checkCrc) {\n      checkCrc(this, length + 4, type);\n    } else {\n      this.skip(4);\n    }\n  }\n  // https://www.w3.org/TR/PNG/#11IHDR\n  decodeIHDR() {\n    const image = this._png;\n    image.width = this.readUint32();\n    image.height = this.readUint32();\n    image.depth = checkBitDepth(this.readUint8());\n    const colorType = this.readUint8();\n    this._colorType = colorType;\n    let channels;\n    switch (colorType) {\n      case ColorType.GREYSCALE:\n        channels = 1;\n        break;\n      case ColorType.TRUECOLOUR:\n        channels = 3;\n        break;\n      case ColorType.INDEXED_COLOUR:\n        channels = 1;\n        break;\n      case ColorType.GREYSCALE_ALPHA:\n        channels = 2;\n        break;\n      case ColorType.TRUECOLOUR_ALPHA:\n        channels = 4;\n        break;\n      // Kept for exhaustiveness.\n      // eslint-disable-next-line unicorn/no-useless-switch-case\n      case ColorType.UNKNOWN:\n      default:\n        throw new Error(\"Unknown color type: \".concat(colorType));\n    }\n    this._png.channels = channels;\n    this._compressionMethod = this.readUint8();\n    if (this._compressionMethod !== CompressionMethod.DEFLATE) {\n      throw new Error(\"Unsupported compression method: \".concat(this._compressionMethod));\n    }\n    this._filterMethod = this.readUint8();\n    this._interlaceMethod = this.readUint8();\n  }\n  decodeACTL() {\n    this._numberOfFrames = this.readUint32();\n    this._numberOfPlays = this.readUint32();\n    this._isAnimated = true;\n  }\n  decodeFCTL() {\n    const image = {\n      sequenceNumber: this.readUint32(),\n      width: this.readUint32(),\n      height: this.readUint32(),\n      xOffset: this.readUint32(),\n      yOffset: this.readUint32(),\n      delayNumber: this.readUint16(),\n      delayDenominator: this.readUint16(),\n      disposeOp: this.readUint8(),\n      blendOp: this.readUint8(),\n      data: new Uint8Array(0)\n    };\n    this._frames.push(image);\n  }\n  // https://www.w3.org/TR/PNG/#11PLTE\n  decodePLTE(length) {\n    if (length % 3 !== 0) {\n      throw new RangeError(\"PLTE field length must be a multiple of 3. Got \".concat(length));\n    }\n    const l = length / 3;\n    this._hasPalette = true;\n    const palette = [];\n    this._palette = palette;\n    for (let i = 0; i < l; i++) {\n      palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);\n    }\n  }\n  // https://www.w3.org/TR/PNG/#11IDAT\n  decodeIDAT(length) {\n    this._writingDataChunks = true;\n    const dataLength = length;\n    const dataOffset = this.offset + this.byteOffset;\n    this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));\n    if (this._inflator.err) {\n      throw new Error(\"Error while decompressing the data: \".concat(this._inflator.err));\n    }\n    this.skip(length);\n  }\n  decodeFDAT(length) {\n    this._writingDataChunks = true;\n    let dataLength = length;\n    let dataOffset = this.offset + this.byteOffset;\n    dataOffset += 4;\n    dataLength -= 4;\n    this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));\n    if (this._inflator.err) {\n      throw new Error(\"Error while decompressing the data: \".concat(this._inflator.err));\n    }\n    this.skip(length);\n  }\n  // https://www.w3.org/TR/PNG/#11tRNS\n  decodetRNS(length) {\n    switch (this._colorType) {\n      case ColorType.GREYSCALE:\n      case ColorType.TRUECOLOUR:\n        {\n          if (length % 2 !== 0) {\n            throw new RangeError(\"tRNS chunk length must be a multiple of 2. Got \".concat(length));\n          }\n          if (length / 2 > this._png.width * this._png.height) {\n            throw new Error(\"tRNS chunk contains more alpha values than there are pixels (\".concat(length / 2, \" vs \").concat(this._png.width * this._png.height, \")\"));\n          }\n          this._hasTransparency = true;\n          this._transparency = new Uint16Array(length / 2);\n          for (let i = 0; i < length / 2; i++) {\n            this._transparency[i] = this.readUint16();\n          }\n          break;\n        }\n      case ColorType.INDEXED_COLOUR:\n        {\n          if (length > this._palette.length) {\n            throw new Error(\"tRNS chunk contains more alpha values than there are palette colors (\".concat(length, \" vs \").concat(this._palette.length, \")\"));\n          }\n          let i = 0;\n          for (; i < length; i++) {\n            const alpha = this.readByte();\n            this._palette[i].push(alpha);\n          }\n          for (; i < this._palette.length; i++) {\n            this._palette[i].push(255);\n          }\n          break;\n        }\n      // Kept for exhaustiveness.\n      /* eslint-disable unicorn/no-useless-switch-case */\n      case ColorType.UNKNOWN:\n      case ColorType.GREYSCALE_ALPHA:\n      case ColorType.TRUECOLOUR_ALPHA:\n      default:\n        {\n          throw new Error(\"tRNS chunk is not supported for color type \".concat(this._colorType));\n        }\n      /* eslint-enable unicorn/no-useless-switch-case */\n    }\n  }\n  // https://www.w3.org/TR/PNG/#11iCCP\n  decodeiCCP(length) {\n    const name = readKeyword(this);\n    const compressionMethod = this.readUint8();\n    if (compressionMethod !== CompressionMethod.DEFLATE) {\n      throw new Error(\"Unsupported iCCP compression method: \".concat(compressionMethod));\n    }\n    const compressedProfile = this.readBytes(length - name.length - 2);\n    this._png.iccEmbeddedProfile = {\n      name,\n      profile: inflate(compressedProfile)\n    };\n  }\n  // https://www.w3.org/TR/PNG/#11pHYs\n  decodepHYs() {\n    const ppuX = this.readUint32();\n    const ppuY = this.readUint32();\n    const unitSpecifier = this.readByte();\n    this._png.resolution = {\n      x: ppuX,\n      y: ppuY,\n      unit: unitSpecifier\n    };\n  }\n  decodeApngImage() {\n    this._apng.width = this._png.width;\n    this._apng.height = this._png.height;\n    this._apng.channels = this._png.channels;\n    this._apng.depth = this._png.depth;\n    this._apng.numberOfFrames = this._numberOfFrames;\n    this._apng.numberOfPlays = this._numberOfPlays;\n    this._apng.text = this._png.text;\n    this._apng.resolution = this._png.resolution;\n    for (let i = 0; i < this._numberOfFrames; i++) {\n      const newFrame = {\n        sequenceNumber: this._frames[i].sequenceNumber,\n        delayNumber: this._frames[i].delayNumber,\n        delayDenominator: this._frames[i].delayDenominator,\n        data: this._apng.depth === 8 ? new Uint8Array(this._apng.width * this._apng.height * this._apng.channels) : new Uint16Array(this._apng.width * this._apng.height * this._apng.channels)\n      };\n      const frame = this._frames.at(i);\n      if (frame) {\n        frame.data = decodeInterlaceNull({\n          data: frame.data,\n          width: frame.width,\n          height: frame.height,\n          channels: this._apng.channels,\n          depth: this._apng.depth\n        });\n        if (this._hasPalette) {\n          this._apng.palette = this._palette;\n        }\n        if (this._hasTransparency) {\n          this._apng.transparency = this._transparency;\n        }\n        if (i === 0 || frame.xOffset === 0 && frame.yOffset === 0 && frame.width === this._png.width && frame.height === this._png.height) {\n          newFrame.data = frame.data;\n        } else {\n          const prevFrame = this._apng.frames.at(i - 1);\n          this.disposeFrame(frame, prevFrame, newFrame);\n          this.addFrameDataToCanvas(newFrame, frame);\n        }\n        this._apng.frames.push(newFrame);\n      }\n    }\n    return this._apng;\n  }\n  disposeFrame(frame, prevFrame, imageFrame) {\n    switch (frame.disposeOp) {\n      case DisposeOpType.NONE:\n        break;\n      case DisposeOpType.BACKGROUND:\n        for (let row = 0; row < this._png.height; row++) {\n          for (let col = 0; col < this._png.width; col++) {\n            const index = (row * frame.width + col) * this._png.channels;\n            for (let channel = 0; channel < this._png.channels; channel++) {\n              imageFrame.data[index + channel] = 0;\n            }\n          }\n        }\n        break;\n      case DisposeOpType.PREVIOUS:\n        imageFrame.data.set(prevFrame.data);\n        break;\n      default:\n        throw new Error('Unknown disposeOp');\n    }\n  }\n  addFrameDataToCanvas(imageFrame, frame) {\n    const maxValue = 1 << this._png.depth;\n    const calculatePixelIndices = (row, col) => {\n      const index = ((row + frame.yOffset) * this._png.width + frame.xOffset + col) * this._png.channels;\n      const frameIndex = (row * frame.width + col) * this._png.channels;\n      return {\n        index,\n        frameIndex\n      };\n    };\n    switch (frame.blendOp) {\n      case BlendOpType.SOURCE:\n        for (let row = 0; row < frame.height; row++) {\n          for (let col = 0; col < frame.width; col++) {\n            const {\n              index,\n              frameIndex\n            } = calculatePixelIndices(row, col);\n            for (let channel = 0; channel < this._png.channels; channel++) {\n              imageFrame.data[index + channel] = frame.data[frameIndex + channel];\n            }\n          }\n        }\n        break;\n      // https://www.w3.org/TR/png-3/#13Alpha-channel-processing\n      case BlendOpType.OVER:\n        for (let row = 0; row < frame.height; row++) {\n          for (let col = 0; col < frame.width; col++) {\n            const {\n              index,\n              frameIndex\n            } = calculatePixelIndices(row, col);\n            for (let channel = 0; channel < this._png.channels; channel++) {\n              const sourceAlpha = frame.data[frameIndex + this._png.channels - 1] / maxValue;\n              const foregroundValue = channel % (this._png.channels - 1) === 0 ? 1 : frame.data[frameIndex + channel];\n              const value = Math.floor(sourceAlpha * foregroundValue + (1 - sourceAlpha) * imageFrame.data[index + channel]);\n              imageFrame.data[index + channel] += value;\n            }\n          }\n        }\n        break;\n      default:\n        throw new Error('Unknown blendOp');\n    }\n  }\n  decodeImage() {\n    var _this$_frames;\n    if (this._inflator.err) {\n      throw new Error(\"Error while decompressing the data: \".concat(this._inflator.err));\n    }\n    const data = this._isAnimated ? ((_this$_frames = this._frames) === null || _this$_frames === void 0 ? void 0 : _this$_frames.at(0)).data : this._inflator.result;\n    if (this._filterMethod !== FilterMethod.ADAPTIVE) {\n      throw new Error(\"Filter method \".concat(this._filterMethod, \" not supported\"));\n    }\n    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n      this._png.data = decodeInterlaceNull({\n        data: data,\n        width: this._png.width,\n        height: this._png.height,\n        channels: this._png.channels,\n        depth: this._png.depth\n      });\n    } else if (this._interlaceMethod === InterlaceMethod.ADAM7) {\n      this._png.data = decodeInterlaceAdam7({\n        data: data,\n        width: this._png.width,\n        height: this._png.height,\n        channels: this._png.channels,\n        depth: this._png.depth\n      });\n    } else {\n      throw new Error(\"Interlace method \".concat(this._interlaceMethod, \" not supported\"));\n    }\n    if (this._hasPalette) {\n      this._png.palette = this._palette;\n    }\n    if (this._hasTransparency) {\n      this._png.transparency = this._transparency;\n    }\n  }\n  pushDataToFrame() {\n    const result = this._inflator.result;\n    const lastFrame = this._frames.at(-1);\n    if (lastFrame) {\n      lastFrame.data = result;\n    } else {\n      this._frames.push({\n        sequenceNumber: 0,\n        width: this._png.width,\n        height: this._png.height,\n        xOffset: 0,\n        yOffset: 0,\n        delayNumber: 0,\n        delayDenominator: 0,\n        disposeOp: DisposeOpType.NONE,\n        blendOp: BlendOpType.SOURCE,\n        data: result\n      });\n    }\n    this._inflator = new Inflator();\n    this._writingDataChunks = false;\n  }\n}\nfunction checkBitDepth(value) {\n  if (value !== 1 && value !== 2 && value !== 4 && value !== 8 && value !== 16) {\n    throw new Error(\"invalid bit depth: \".concat(value));\n  }\n  return value;\n}","map":{"version":3,"names":["IOBuffer","inflate","Inflate","Inflator","checkCrc","decodeInterlaceAdam7","decodeInterlaceNull","checkSignature","decodetEXt","readKeyword","textChunkName","ColorType","CompressionMethod","DisposeOpType","FilterMethod","InterlaceMethod","BlendOpType","PngDecoder","constructor","data","options","arguments","length","undefined","_defineProperty","_checkCrc","_inflator","_png","width","height","channels","Uint8Array","depth","text","_apng","numberOfFrames","numberOfPlays","frames","_end","_hasPalette","_palette","_hasTransparency","_transparency","Uint16Array","_compressionMethod","UNKNOWN","_filterMethod","_interlaceMethod","_colorType","_isAnimated","_numberOfFrames","_numberOfPlays","_frames","_writingDataChunks","setBigEndian","decode","readUint32","type","readChars","decodeChunk","decodeImage","decodeApng","decodeApngChunk","decodeApngImage","offset","decodeIHDR","decodePLTE","decodeIDAT","decodetRNS","decodeiCCP","decodepHYs","skip","Error","concat","pushDataToFrame","decodeACTL","decodeFCTL","decodeFDAT","image","checkBitDepth","readUint8","colorType","GREYSCALE","TRUECOLOUR","INDEXED_COLOUR","GREYSCALE_ALPHA","TRUECOLOUR_ALPHA","DEFLATE","sequenceNumber","xOffset","yOffset","delayNumber","readUint16","delayDenominator","disposeOp","blendOp","push","RangeError","l","palette","i","dataLength","dataOffset","byteOffset","buffer","err","alpha","readByte","name","compressionMethod","compressedProfile","readBytes","iccEmbeddedProfile","profile","ppuX","ppuY","unitSpecifier","resolution","x","y","unit","newFrame","frame","at","transparency","prevFrame","disposeFrame","addFrameDataToCanvas","imageFrame","NONE","BACKGROUND","row","col","index","channel","PREVIOUS","set","maxValue","calculatePixelIndices","frameIndex","SOURCE","OVER","sourceAlpha","foregroundValue","value","Math","floor","_this$_frames","result","ADAPTIVE","NO_INTERLACE","ADAM7","lastFrame"],"sources":["C:\\Users\\raman\\OneDrive\\Desktop\\project\\client\\node_modules\\fast-png\\src\\PngDecoder.ts"],"sourcesContent":["import { IOBuffer } from 'iobuffer';\nimport { inflate, Inflate as Inflator } from 'pako';\n\nimport { checkCrc } from './helpers/crc';\nimport { decodeInterlaceAdam7 } from './helpers/decodeInterlaceAdam7';\nimport { decodeInterlaceNull } from './helpers/decodeInterlaceNull';\nimport { checkSignature } from './helpers/signature';\nimport { decodetEXt, readKeyword, textChunkName } from './helpers/text';\nimport {\n  ColorType,\n  CompressionMethod,\n  DisposeOpType,\n  FilterMethod,\n  InterlaceMethod,\n  BlendOpType,\n} from './internalTypes';\nimport type {\n  BitDepth,\n  DecodedPng,\n  DecodedApng,\n  DecodedApngFrame,\n  ApngFrame,\n  DecoderInputType,\n  IndexedColors,\n  PngDecoderOptions,\n} from './types';\n\nexport default class PngDecoder extends IOBuffer {\n  private readonly _checkCrc: boolean;\n  private _inflator: Inflator;\n  private readonly _png: DecodedPng;\n  private readonly _apng: DecodedApng;\n  private _end: boolean;\n  private _hasPalette: boolean;\n  private _palette: IndexedColors;\n  private _hasTransparency: boolean;\n  private _transparency: Uint16Array;\n  private _compressionMethod: CompressionMethod;\n  private _filterMethod: FilterMethod;\n  private _interlaceMethod: InterlaceMethod;\n  private _colorType: ColorType;\n  private _isAnimated: boolean;\n  private _numberOfFrames: number;\n  private _numberOfPlays: number;\n  private _frames: ApngFrame[];\n  private _writingDataChunks: boolean;\n\n  public constructor(data: DecoderInputType, options: PngDecoderOptions = {}) {\n    super(data);\n    const { checkCrc = false } = options;\n    this._checkCrc = checkCrc;\n    this._inflator = new Inflator();\n    this._png = {\n      width: -1,\n      height: -1,\n      channels: -1,\n      data: new Uint8Array(0),\n      depth: 1,\n      text: {},\n    };\n    this._apng = {\n      width: -1,\n      height: -1,\n      channels: -1,\n      depth: 1,\n      numberOfFrames: 1,\n      numberOfPlays: 0,\n      text: {},\n      frames: [],\n    };\n    this._end = false;\n    this._hasPalette = false;\n    this._palette = [];\n    this._hasTransparency = false;\n    this._transparency = new Uint16Array(0);\n    this._compressionMethod = CompressionMethod.UNKNOWN;\n    this._filterMethod = FilterMethod.UNKNOWN;\n    this._interlaceMethod = InterlaceMethod.UNKNOWN;\n    this._colorType = ColorType.UNKNOWN;\n    this._isAnimated = false;\n    this._numberOfFrames = 1;\n    this._numberOfPlays = 0;\n    this._frames = [];\n    this._writingDataChunks = false;\n    // PNG is always big endian\n    // https://www.w3.org/TR/PNG/#7Integers-and-byte-order\n    this.setBigEndian();\n  }\n\n  public decode(): DecodedPng {\n    checkSignature(this);\n    while (!this._end) {\n      const length = this.readUint32();\n      const type = this.readChars(4);\n\n      this.decodeChunk(length, type);\n    }\n    this.decodeImage();\n\n    return this._png;\n  }\n\n  public decodeApng(): DecodedApng {\n    checkSignature(this);\n    while (!this._end) {\n      const length = this.readUint32();\n      const type = this.readChars(4);\n\n      this.decodeApngChunk(length, type);\n    }\n    this.decodeApngImage();\n    return this._apng;\n  }\n\n  // https://www.w3.org/TR/PNG/#5Chunk-layout\n  private decodeChunk(length: number, type: string): void {\n    const offset = this.offset;\n    switch (type) {\n      // 11.2 Critical chunks\n      case 'IHDR': // 11.2.2 IHDR Image header\n        this.decodeIHDR();\n        break;\n      case 'PLTE': // 11.2.3 PLTE Palette\n        this.decodePLTE(length);\n        break;\n      case 'IDAT': // 11.2.4 IDAT Image data\n        this.decodeIDAT(length);\n        break;\n      case 'IEND': // 11.2.5 IEND Image trailer\n        this._end = true;\n        break;\n      // 11.3 Ancillary chunks\n      case 'tRNS': // 11.3.2.1 tRNS Transparency\n        this.decodetRNS(length);\n        break;\n      case 'iCCP': // 11.3.3.3 iCCP Embedded ICC profile\n        this.decodeiCCP(length);\n        break;\n      case textChunkName: // 11.3.4.3 tEXt Textual data\n        decodetEXt(this._png.text, this, length);\n        break;\n      case 'pHYs': // 11.3.5.3 pHYs Physical pixel dimensions\n        this.decodepHYs();\n        break;\n      default:\n        this.skip(length);\n        break;\n    }\n    if (this.offset - offset !== length) {\n      throw new Error(`Length mismatch while decoding chunk ${type}`);\n    }\n    if (this._checkCrc) {\n      checkCrc(this, length + 4, type);\n    } else {\n      this.skip(4);\n    }\n  }\n  private decodeApngChunk(length: number, type: string): void {\n    const offset = this.offset;\n    if (type !== 'fdAT' && type !== 'IDAT' && this._writingDataChunks) {\n      this.pushDataToFrame();\n    }\n    switch (type) {\n      case 'acTL':\n        this.decodeACTL();\n        break;\n      case 'fcTL':\n        this.decodeFCTL();\n        break;\n      case 'fdAT':\n        this.decodeFDAT(length);\n        break;\n      default:\n        this.decodeChunk(length, type);\n        this.offset = offset + length;\n        break;\n    }\n    if (this.offset - offset !== length) {\n      throw new Error(`Length mismatch while decoding chunk ${type}`);\n    }\n    if (this._checkCrc) {\n      checkCrc(this, length + 4, type);\n    } else {\n      this.skip(4);\n    }\n  }\n\n  // https://www.w3.org/TR/PNG/#11IHDR\n  private decodeIHDR(): void {\n    const image = this._png;\n\n    image.width = this.readUint32();\n    image.height = this.readUint32();\n    image.depth = checkBitDepth(this.readUint8());\n\n    const colorType = this.readUint8() as ColorType;\n    this._colorType = colorType;\n    let channels: number;\n    switch (colorType) {\n      case ColorType.GREYSCALE:\n        channels = 1;\n        break;\n      case ColorType.TRUECOLOUR:\n        channels = 3;\n        break;\n      case ColorType.INDEXED_COLOUR:\n        channels = 1;\n        break;\n      case ColorType.GREYSCALE_ALPHA:\n        channels = 2;\n        break;\n      case ColorType.TRUECOLOUR_ALPHA:\n        channels = 4;\n        break;\n      // Kept for exhaustiveness.\n      // eslint-disable-next-line unicorn/no-useless-switch-case\n      case ColorType.UNKNOWN:\n      default:\n        throw new Error(`Unknown color type: ${colorType}`);\n    }\n    this._png.channels = channels;\n\n    this._compressionMethod = this.readUint8() as CompressionMethod;\n    if (this._compressionMethod !== CompressionMethod.DEFLATE) {\n      throw new Error(\n        `Unsupported compression method: ${this._compressionMethod}`,\n      );\n    }\n\n    this._filterMethod = this.readUint8() as FilterMethod;\n    this._interlaceMethod = this.readUint8() as InterlaceMethod;\n  }\n\n  private decodeACTL(): void {\n    this._numberOfFrames = this.readUint32();\n    this._numberOfPlays = this.readUint32();\n    this._isAnimated = true;\n  }\n\n  private decodeFCTL(): void {\n    const image: ApngFrame = {\n      sequenceNumber: this.readUint32(),\n      width: this.readUint32(),\n      height: this.readUint32(),\n      xOffset: this.readUint32(),\n      yOffset: this.readUint32(),\n      delayNumber: this.readUint16(),\n      delayDenominator: this.readUint16(),\n      disposeOp: this.readUint8(),\n      blendOp: this.readUint8(),\n      data: new Uint8Array(0),\n    };\n    this._frames.push(image);\n  }\n  // https://www.w3.org/TR/PNG/#11PLTE\n  private decodePLTE(length: number): void {\n    if (length % 3 !== 0) {\n      throw new RangeError(\n        `PLTE field length must be a multiple of 3. Got ${length}`,\n      );\n    }\n    const l = length / 3;\n\n    this._hasPalette = true;\n    const palette: IndexedColors = [];\n    this._palette = palette;\n    for (let i = 0; i < l; i++) {\n      palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);\n    }\n  }\n\n  // https://www.w3.org/TR/PNG/#11IDAT\n  private decodeIDAT(length: number): void {\n    this._writingDataChunks = true;\n    const dataLength = length;\n    const dataOffset = this.offset + this.byteOffset;\n\n    this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));\n    if (this._inflator.err) {\n      throw new Error(\n        `Error while decompressing the data: ${this._inflator.err}`,\n      );\n    }\n    this.skip(length);\n  }\n  private decodeFDAT(length: number): void {\n    this._writingDataChunks = true;\n    let dataLength = length;\n    let dataOffset = this.offset + this.byteOffset;\n    dataOffset += 4;\n    dataLength -= 4;\n    this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));\n    if (this._inflator.err) {\n      throw new Error(\n        `Error while decompressing the data: ${this._inflator.err}`,\n      );\n    }\n    this.skip(length);\n  }\n\n  // https://www.w3.org/TR/PNG/#11tRNS\n  private decodetRNS(length: number): void {\n    switch (this._colorType) {\n      case ColorType.GREYSCALE:\n      case ColorType.TRUECOLOUR: {\n        if (length % 2 !== 0) {\n          throw new RangeError(\n            `tRNS chunk length must be a multiple of 2. Got ${length}`,\n          );\n        }\n        if (length / 2 > this._png.width * this._png.height) {\n          throw new Error(\n            `tRNS chunk contains more alpha values than there are pixels (${\n              length / 2\n            } vs ${this._png.width * this._png.height})`,\n          );\n        }\n        this._hasTransparency = true;\n        this._transparency = new Uint16Array(length / 2);\n\n        for (let i = 0; i < length / 2; i++) {\n          this._transparency[i] = this.readUint16();\n        }\n\n        break;\n      }\n      case ColorType.INDEXED_COLOUR: {\n        if (length > this._palette.length) {\n          throw new Error(\n            `tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`,\n          );\n        }\n        let i = 0;\n        for (; i < length; i++) {\n          const alpha = this.readByte();\n          this._palette[i].push(alpha);\n        }\n        for (; i < this._palette.length; i++) {\n          this._palette[i].push(255);\n        }\n        break;\n      }\n      // Kept for exhaustiveness.\n      /* eslint-disable unicorn/no-useless-switch-case */\n      case ColorType.UNKNOWN:\n      case ColorType.GREYSCALE_ALPHA:\n      case ColorType.TRUECOLOUR_ALPHA:\n      default: {\n        throw new Error(\n          `tRNS chunk is not supported for color type ${this._colorType}`,\n        );\n      }\n      /* eslint-enable unicorn/no-useless-switch-case */\n    }\n  }\n\n  // https://www.w3.org/TR/PNG/#11iCCP\n  private decodeiCCP(length: number): void {\n    const name = readKeyword(this);\n    const compressionMethod = this.readUint8();\n    if (compressionMethod !== CompressionMethod.DEFLATE) {\n      throw new Error(\n        `Unsupported iCCP compression method: ${compressionMethod}`,\n      );\n    }\n    const compressedProfile = this.readBytes(length - name.length - 2);\n    this._png.iccEmbeddedProfile = {\n      name,\n      profile: inflate(compressedProfile),\n    };\n  }\n\n  // https://www.w3.org/TR/PNG/#11pHYs\n  private decodepHYs(): void {\n    const ppuX = this.readUint32();\n    const ppuY = this.readUint32();\n    const unitSpecifier = this.readByte();\n    this._png.resolution = { x: ppuX, y: ppuY, unit: unitSpecifier };\n  }\n\n  private decodeApngImage() {\n    this._apng.width = this._png.width;\n    this._apng.height = this._png.height;\n    this._apng.channels = this._png.channels;\n    this._apng.depth = this._png.depth;\n    this._apng.numberOfFrames = this._numberOfFrames;\n    this._apng.numberOfPlays = this._numberOfPlays;\n    this._apng.text = this._png.text;\n    this._apng.resolution = this._png.resolution;\n    for (let i = 0; i < this._numberOfFrames; i++) {\n      const newFrame: DecodedApngFrame = {\n        sequenceNumber: this._frames[i].sequenceNumber,\n        delayNumber: this._frames[i].delayNumber,\n        delayDenominator: this._frames[i].delayDenominator,\n        data:\n          this._apng.depth === 8\n            ? new Uint8Array(\n                this._apng.width * this._apng.height * this._apng.channels,\n              )\n            : new Uint16Array(\n                this._apng.width * this._apng.height * this._apng.channels,\n              ),\n      };\n\n      const frame = this._frames.at(i);\n\n      if (frame) {\n        frame.data = decodeInterlaceNull({\n          data: frame.data as Uint8Array,\n          width: frame.width,\n          height: frame.height,\n          channels: this._apng.channels,\n          depth: this._apng.depth,\n        });\n\n        if (this._hasPalette) {\n          this._apng.palette = this._palette;\n        }\n        if (this._hasTransparency) {\n          this._apng.transparency = this._transparency;\n        }\n        if (\n          i === 0 ||\n          (frame.xOffset === 0 &&\n            frame.yOffset === 0 &&\n            frame.width === this._png.width &&\n            frame.height === this._png.height)\n        ) {\n          newFrame.data = frame.data;\n        } else {\n          const prevFrame = this._apng.frames.at(i - 1);\n          this.disposeFrame(frame, prevFrame as DecodedApngFrame, newFrame);\n          this.addFrameDataToCanvas(newFrame, frame);\n        }\n        this._apng.frames.push(newFrame);\n      }\n    }\n    return this._apng;\n  }\n  private disposeFrame(\n    frame: ApngFrame,\n    prevFrame: DecodedApngFrame,\n    imageFrame: DecodedApngFrame,\n  ): void {\n    switch (frame.disposeOp) {\n      case DisposeOpType.NONE:\n        break;\n      case DisposeOpType.BACKGROUND:\n        for (let row = 0; row < this._png.height; row++) {\n          for (let col = 0; col < this._png.width; col++) {\n            const index = (row * frame.width + col) * this._png.channels;\n            for (let channel = 0; channel < this._png.channels; channel++) {\n              imageFrame.data[index + channel] = 0;\n            }\n          }\n        }\n        break;\n      case DisposeOpType.PREVIOUS:\n        imageFrame.data.set(prevFrame.data);\n        break;\n      default:\n        throw new Error('Unknown disposeOp');\n    }\n  }\n  private addFrameDataToCanvas(\n    imageFrame: DecodedApngFrame,\n    frame: ApngFrame,\n  ): void {\n    const maxValue = 1 << this._png.depth;\n    const calculatePixelIndices = (row: number, col: number) => {\n      const index =\n        ((row + frame.yOffset) * this._png.width + frame.xOffset + col) *\n        this._png.channels;\n      const frameIndex = (row * frame.width + col) * this._png.channels;\n      return { index, frameIndex };\n    };\n    switch (frame.blendOp) {\n      case BlendOpType.SOURCE:\n        for (let row = 0; row < frame.height; row++) {\n          for (let col = 0; col < frame.width; col++) {\n            const { index, frameIndex } = calculatePixelIndices(row, col);\n            for (let channel = 0; channel < this._png.channels; channel++) {\n              imageFrame.data[index + channel] =\n                frame.data[frameIndex + channel];\n            }\n          }\n        }\n        break;\n      // https://www.w3.org/TR/png-3/#13Alpha-channel-processing\n      case BlendOpType.OVER:\n        for (let row = 0; row < frame.height; row++) {\n          for (let col = 0; col < frame.width; col++) {\n            const { index, frameIndex } = calculatePixelIndices(row, col);\n            for (let channel = 0; channel < this._png.channels; channel++) {\n              const sourceAlpha =\n                frame.data[frameIndex + this._png.channels - 1] / maxValue;\n              const foregroundValue =\n                channel % (this._png.channels - 1) === 0\n                  ? 1\n                  : frame.data[frameIndex + channel];\n              const value = Math.floor(\n                sourceAlpha * foregroundValue +\n                  (1 - sourceAlpha) * imageFrame.data[index + channel],\n              );\n              imageFrame.data[index + channel] += value;\n            }\n          }\n        }\n        break;\n      default:\n        throw new Error('Unknown blendOp');\n    }\n  }\n  private decodeImage(): void {\n    if (this._inflator.err) {\n      throw new Error(\n        `Error while decompressing the data: ${this._inflator.err}`,\n      );\n    }\n\n    const data = this._isAnimated\n      ? (this._frames?.at(0) as ApngFrame).data\n      : this._inflator.result;\n\n    if (this._filterMethod !== FilterMethod.ADAPTIVE) {\n      throw new Error(`Filter method ${this._filterMethod} not supported`);\n    }\n\n    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n      this._png.data = decodeInterlaceNull({\n        data: data as Uint8Array,\n        width: this._png.width,\n        height: this._png.height,\n        channels: this._png.channels,\n        depth: this._png.depth,\n      });\n    } else if (this._interlaceMethod === InterlaceMethod.ADAM7) {\n      this._png.data = decodeInterlaceAdam7({\n        data: data as Uint8Array,\n        width: this._png.width,\n        height: this._png.height,\n        channels: this._png.channels,\n        depth: this._png.depth,\n      });\n    } else {\n      throw new Error(\n        `Interlace method ${this._interlaceMethod} not supported`,\n      );\n    }\n\n    if (this._hasPalette) {\n      this._png.palette = this._palette;\n    }\n    if (this._hasTransparency) {\n      this._png.transparency = this._transparency;\n    }\n  }\n\n  private pushDataToFrame() {\n    const result = this._inflator.result;\n    const lastFrame = this._frames.at(-1);\n    if (lastFrame) {\n      lastFrame.data = result as Uint8Array;\n    } else {\n      this._frames.push({\n        sequenceNumber: 0,\n        width: this._png.width,\n        height: this._png.height,\n        xOffset: 0,\n        yOffset: 0,\n        delayNumber: 0,\n        delayDenominator: 0,\n        disposeOp: DisposeOpType.NONE,\n        blendOp: BlendOpType.SOURCE,\n        data: result as Uint8Array,\n      });\n    }\n    this._inflator = new Inflator();\n    this._writingDataChunks = false;\n  }\n}\n\nfunction checkBitDepth(value: number): BitDepth {\n  if (\n    value !== 1 &&\n    value !== 2 &&\n    value !== 4 &&\n    value !== 8 &&\n    value !== 16\n  ) {\n    throw new Error(`invalid bit depth: ${value}`);\n  }\n  return value;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}